## 代码解读：
(buddy.c位于oslab2\kernel\include\mm中)
### init_buddy()
这个函数用于初始化物理内存池（phys_mem_pool），但其返回值为void，所以与我们要写的无关（。

关于phys_mem_pool结构体（位于oslab2\kernel\include的buddy.h中）：
![image](https://github.com/litterqi/operating-system/assets/123362884/a34e3cf2-d599-4893-bbde-307429663865)
空闲链表数组在pool中。
### get_buddy_chunk()
这段代码实现了一个获取兄弟块（buddy chunk）的函数，用于在伙伴系统中找到某个内存块的伙伴块。如果伙伴块存在且未被分配，返回伙伴块对应的页面元数据的指针，否则返回NULL。

和`init_buddy()`函数一样，具体代码我们不用管（。

关于page结构体（也在buddy.h中）：
![image](https://github.com/litterqi/operating-system/assets/123362884/683005db-cda5-489b-a608-d749aed718ff)
### list.h中的函数：
(list.h位于oslab2\kernel\include\common中)
#### struct list_head
用于实现双向链表的节点。
#### init_list_head()
这个函数将一个list_head结构体作为头节点，并将其初始化为空链表。
#### list_add()
这个函数将一个新的节点插入到双向链表中，作为头节点之后的第一个节点。
#### list_append()
这个函数将一个新的节点追加到双向链表的尾部。
#### list_del()
这个函数从双向链表中删除指定的节点。
#### list_empty()
这个函数可以检查双向链表是否为空。如果返回值为true，表示链表为空；如果返回值为false，表示链表非空。
## 答案解读：
