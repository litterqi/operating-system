## 代码解读：
(buddy.c位于oslab2\kernel\mm中)
### init_buddy()
这个函数用于初始化物理内存池（phys_mem_pool），但其返回值为void，所以与我们要写的无关（。

关于phys_mem_pool结构体（位于oslab2\kernel\include的buddy.h中）：
![image](https://github.com/litterqi/operating-system/assets/123362884/a34e3cf2-d599-4893-bbde-307429663865)
空闲链表数组在pool中。
### get_buddy_chunk()
这段代码实现了一个获取兄弟块（buddy chunk）的函数，用于在伙伴系统中找到某个内存块的伙伴块。如果伙伴块存在且未被分配，返回伙伴块对应的页面元数据的指针，否则返回NULL。

和`init_buddy()`函数一样，具体代码我们不用管（。

关于page结构体（也在buddy.h中）：
![image](https://github.com/litterqi/operating-system/assets/123362884/683005db-cda5-489b-a608-d749aed718ff)
### list.h中的函数：
(list.h位于oslab2\kernel\include\common中)
#### struct list_head
用于实现双向链表的节点。
#### init_list_head()
这个函数将一个list_head结构体作为头节点，并将其初始化为空链表。
#### list_add()
这个函数将一个新的节点插入到双向链表中，作为头节点之后的第一个节点。
#### list_append()
这个函数将一个新的节点追加到双向链表的尾部。
#### list_del()
这个函数从双向链表中删除指定的节点。
#### list_empty()
这个函数可以检查双向链表是否为空。如果返回值为true，表示链表为空；如果返回值为false，表示链表非空。
## 答案解读：
### split_page()
```
while (page->order != order) {
                struct page *buddy;

                // split
                --page->order;

                buddy = get_buddy_chunk(pool, page);
                buddy->order = page->order;
                buddy->allocated = 0;

                ++pool->free_lists[buddy->order].nr_free;
                list_add(&(buddy->node), &(pool->free_lists[buddy->order].free_list));
        }
```
![image](https://github.com/litterqi/operating-system/assets/123362884/78b710da-b6c9-4c42-b286-e05b92c22297)
![image](https://github.com/litterqi/operating-system/assets/123362884/9b1cb2ad-fc5f-4227-af09-cdf2b0e59380)

关于`page->order`：

![image](https://github.com/litterqi/operating-system/assets/123362884/dc675208-93b9-40ee-85b9-b85d33ddfcf3)

```
// should never be null
        BUG_ON(page == NULL);
        return page;
```
![image](https://github.com/litterqi/operating-system/assets/123362884/5eb13c36-58d0-43f7-9748-cd0836b31b46)

个人对这个函数功能的理解：
![image](https://github.com/litterqi/operating-system/assets/123362884/34e708d6-0bf9-456b-8128-544a40d83b3b)
### buddy_get_pages()
```
struct page *res = NULL;
        
        for (u64 i = order; i < BUDDY_MAX_ORDER; ++i) {
                if (pool->free_lists[i].nr_free) {
                        struct list_head *to_be_split = pool->free_lists[i].free_list.next;

                        struct page *page = list_entry(to_be_split, struct page, node);
                        --pool->free_lists[page->order].nr_free;
                        list_del(&(page->node));

                        res = split_page(pool, order, page);
                        res->allocated = 1;
                        break;
                }
        }

        // nullable
        return res;
```
该函数用于从一个物理内存池中获取一定数量的页面，分配指定阶大小的连续物理页。

定义一个指向页面结构的指针res，用于保存分配的页面指针。初始化为NULL。接下来，使用循环遍历查找适合满足需求的页面大小的空闲页面。从order开始遍历到最大可用的页面大小BUDDY_MAX_ORDER。
在循环中，首先检查当前页面大小的空闲列表中是否有空闲页可用，如果有则进入循环。

为什么for循环从order开始遍历呢？

这是因为这个函数需要找到大小满足order的空闲页表，所以我们遍历的空闲链表其空闲块的最小size就是order。

![image](https://github.com/litterqi/operating-system/assets/123362884/c6cf702d-56ed-413b-8c32-cf4e4fb4a8d2)
![image](https://github.com/litterqi/operating-system/assets/123362884/ad579c91-ce11-44c6-804b-d65660dfc1ad)

`list_entry()`用于将链表节点指针转化为包含这个节点的结构体指针。
### merge_page()
```
while (page->order < BUDDY_MAX_ORDER - 1) {
                struct page *buddy = get_buddy_chunk(pool, page);
                if (buddy == NULL || buddy->allocated || buddy->order != page->order) {
                        break;
                }

                --pool->free_lists[buddy->order].nr_free;
                list_del(&(buddy->node));

                if (page > buddy) {
                        page = buddy;
                }

                ++page->order;
        }

        return page;
```
![image](https://github.com/litterqi/operating-system/assets/123362884/7dd568f5-4278-4f1d-b9fe-b3109a8f64a0)
这个函数可以看成是`split_page()`的逆过程。

为什么循环条件是`page->order<BUDDY_MAX_ORDER-1`呢？

首先，我们根据上一个函数的for循环条件(`for (u64 i = order; i < BUDDY_MAX_ORDER; ++i)`)可知`BUDDY_MAX_ORDER-1`是伙伴系统最大页面大小。猜测这样写是因为最大的页面是没有对应的buddy页面的，所以是`page->order<BUDDY_MAX_ORDER-1`。

### buddy_free_pages()
```
struct page *merged_page = merge_page(pool, page);

        merged_page->allocated = 0;
        ++pool->free_lists[merged_page->order].nr_free;
        list_add(&(merged_page->node), &(pool->free_lists[merged_page->order].free_list));
```
![image](https://github.com/litterqi/operating-system/assets/123362884/b7a53957-fa42-4730-a953-aab77f434696)

该函数用于释放已分配的连续物理页。

练习2成功！

![image](https://github.com/litterqi/operating-system/assets/123362884/a8b5075e-892a-47e3-828b-b65324a9d2c3)
