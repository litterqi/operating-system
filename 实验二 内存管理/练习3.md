## 1.代码解读：
md练习三有点看不懂了（

(page_table.c位于oslab2\kernel\arch\aarch64\mm中)
### set_page_table()
```
extern void set_ttbr0_el1(paddr_t);

void set_page_table(paddr_t pgtbl)
{
        set_ttbr0_el1(pgtbl);
}
```
![image](https://github.com/litterqi/operating-system/assets/123362884/de2976cf-c520-4877-83f0-7ce96d53d6d0)
这个函数的作用是设置页表，将传入的物理页表地址设置为当前CPU的页表基址。

### USER_PTE
```
#define USER_PTE 0
/*
 * the 3rd arg means the kind of PTE.
 */
```
定义一个名为USER_PTE的宏，值为0。(不知道注释什么意思)

### set_pte_flags()
```
static int set_pte_flags(pte_t *entry, vmr_prop_t flags, int kind)
{
        // Only consider USER PTE now.
        BUG_ON(kind != USER_PTE);

        /*
         * Current access permission (AP) setting:
         * Mapped pages are always readable (No considering XOM).
         * EL1 can directly access EL0 (No restriction like SMAP
         * as ChCore is a microkernel).
         */
        if (flags & VMR_WRITE)
                entry->l3_page.AP = AARCH64_MMU_ATTR_PAGE_AP_HIGH_RW_EL0_RW;
        else
                entry->l3_page.AP = AARCH64_MMU_ATTR_PAGE_AP_HIGH_RO_EL0_RO;

        if (flags & VMR_EXEC)
                entry->l3_page.UXN = AARCH64_MMU_ATTR_PAGE_UX;
        else
                entry->l3_page.UXN = AARCH64_MMU_ATTR_PAGE_UXN;

        // EL1 cannot directly execute EL0 accessiable region.
        entry->l3_page.PXN = AARCH64_MMU_ATTR_PAGE_PXN;
        // Set AF (access flag) in advance.
        entry->l3_page.AF = AARCH64_MMU_ATTR_PAGE_AF_ACCESSED;
        // Mark the mapping as not global
        entry->l3_page.nG = 1;
        // Mark the mappint as inner sharable
        entry->l3_page.SH = INNER_SHAREABLE;
        // Set the memory type
        if (flags & VMR_DEVICE) {
                entry->l3_page.attr_index = DEVICE_MEMORY;
                entry->l3_page.SH = 0;
        } else if (flags & VMR_NOCACHE) {
                entry->l3_page.attr_index = NORMAL_MEMORY_NOCACHE;
        } else {
                entry->l3_page.attr_index = NORMAL_MEMORY;
        }

        return 0;
}
```
![image](https://github.com/litterqi/operating-system/assets/123362884/476614a8-1246-4ee1-99af-a8237535b519)

### 接下来是一些宏和常量
```
#define GET_PADDR_IN_PTE(entry) \
        (((u64)entry->table.next_table_addr) << PAGE_SHIFT)
#define GET_NEXT_PTP(entry) phys_to_virt(GET_PADDR_IN_PTE(entry))
```
`GET_PADDR_IN_PTE`宏接受一个参数`entry`，它是一个页表项的指针。这个宏计算了页表项中存储的下一级页表的物理地址，并将其左移`PAGE_SHIFT`位，得到真实的物理地址。

`GET_NEXT_PTP`宏也接受一个参数`entry`，它调用了`GET_PADDR_IN_PTE`宏来获取下一级页表的物理地址，并使用`phys_to_virt`函数将物理地址转换为虚拟地址，返回虚拟地址的结果。

```
#define NORMAL_PTP (0)
#define BLOCK_PTP  (1)
```
这两个常量分别表示普通页表项（例如页表项指向下一级页表）和块页表项（例如页表项指向页），它们的值分别为 0 和 1。

### get_next_ptp()
```
static int get_next_ptp(ptp_t *cur_ptp, u32 level, vaddr_t va, ptp_t **next_ptp,
                        pte_t **pte, bool alloc)
{
        u32 index = 0;
        pte_t *entry;

        if (cur_ptp == NULL)
                return -ENOMAPPING;

        switch (level) {
        case 0:
                index = GET_L0_INDEX(va);
                break;
        case 1:
                index = GET_L1_INDEX(va);
                break;
        case 2:
                index = GET_L2_INDEX(va);
                break;
        case 3:
                index = GET_L3_INDEX(va);
                break;
        default:
                BUG_ON(1);
        }

        entry = &(cur_ptp->ent[index]);
        if (IS_PTE_INVALID(entry->pte)) {
                if (alloc == false) {
                        return -ENOMAPPING;
                } else {
                        /* alloc a new page table page */
                        ptp_t *new_ptp;
                        paddr_t new_ptp_paddr;
                        pte_t new_pte_val;

                        /* alloc a single physical page as a new page table page
                         */
                        new_ptp = get_pages(0);
                        BUG_ON(new_ptp == NULL);
                        memset((void *)new_ptp, 0, PAGE_SIZE);
                        new_ptp_paddr = virt_to_phys((vaddr_t)new_ptp);

                        new_pte_val.pte = 0;
                        new_pte_val.table.is_valid = 1;
                        new_pte_val.table.is_table = 1;
                        new_pte_val.table.next_table_addr = new_ptp_paddr
                                                            >> PAGE_SHIFT;

                        /* same effect as: cur_ptp->ent[index] = new_pte_val; */
                        entry->pte = new_pte_val.pte;
                }
        }

        *next_ptp = (ptp_t *)GET_NEXT_PTP(entry);
        *pte = entry;
        if (IS_PTE_TABLE(entry->pte))
                return NORMAL_PTP;
        else
                return BLOCK_PTP;
}
```
![image](https://github.com/litterqi/operating-system/assets/123362884/2466c6e9-e313-4a05-aeb1-4e8315e3240f)

```
/*
 * Find next page table page for the "va".
 *
 * cur_ptp: current page table page
 * level:   current ptp level
 *
 * next_ptp: returns "next_ptp"
 * pte     : returns "pte" (points to next_ptp) in "cur_ptp"
 *
 * alloc: if true, allocate a ptp when missing
 *
 */
```
参考注释，这个函数的作用是根据给定的虚拟地址 "va" 找到下一个页表页，在在缺失页表页时分配一个新的页表页。

### free_page_table()
```
void free_page_table(void *pgtbl)
{
        ptp_t *l0_ptp, *l1_ptp, *l2_ptp, *l3_ptp;
        pte_t *l0_pte, *l1_pte, *l2_pte;
        int i, j, k;

        if (pgtbl == NULL) {
                kwarn("%s: input arg is NULL.\n", __func__);
                return;
        }

        /* L0 page table */
        l0_ptp = (ptp_t *)pgtbl;

        /* Interate each entry in the l0 page table*/
        for (i = 0; i < PTP_ENTRIES; ++i) {
                l0_pte = &l0_ptp->ent[i];
                if (IS_PTE_INVALID(l0_pte->pte) || !IS_PTE_TABLE(l0_pte->pte))
                        continue;
                l1_ptp = (ptp_t *)GET_NEXT_PTP(l0_pte);

                /* Interate each entry in the l1 page table*/
                for (j = 0; j < PTP_ENTRIES; ++j) {
                        l1_pte = &l1_ptp->ent[j];
                        if (IS_PTE_INVALID(l1_pte->pte)
                            || !IS_PTE_TABLE(l1_pte->pte))
                                continue;
                        l2_ptp = (ptp_t *)GET_NEXT_PTP(l1_pte);

                        /* Interate each entry in the l2 page table*/
                        for (k = 0; k < PTP_ENTRIES; ++k) {
                                l2_pte = &l2_ptp->ent[k];
                                if (IS_PTE_INVALID(l2_pte->pte)
                                    || !IS_PTE_TABLE(l2_pte->pte))
                                        continue;
                                l3_ptp = (ptp_t *)GET_NEXT_PTP(l2_pte);
                                /* Free the l3 page table page */
                                free_pages(l3_ptp);
                        }

                        /* Free the l2 page table page */
                        free_pages(l2_ptp);
                }

                /* Free the l1 page table page */
                free_pages(l1_ptp);
        }

        free_pages(l0_ptp);
}
```
![image](https://github.com/litterqi/operating-system/assets/123362884/cd56faa9-7da3-48fb-a743-42e2d8017ee4)

代码解读完毕(感觉没懂什么东西)。

## 2.答案解读：
### query_in_pgtbl()
```
ptp_t *current_ptp;
pte_t *pte;
int res;
```
这里声明了三个变量：current_ptp 是当前页表指针，pte 是页表项指针，res 是操作结果的存储变量。
```
current_ptp = (ptp_t *)pgtbl;
res = get_next_ptp(current_ptp, 0, va, &current_ptp, &pte, false);
if (res == -ENOMAPPING) {
    return res;
}
```
![image](https://github.com/litterqi/operating-system/assets/123362884/014678ea-1336-422f-be57-135b0a6f8750)

```
res = get_next_ptp(current_ptp, 1, va, &current_ptp, &pte, false);
if (res == -ENOMAPPING) {
    return res;
}
else if (res == BLOCK_PTP) {
    if (entry != NULL) {
        *entry = pte;
    }
    *pa = virt_to_phys(current_ptp) + GET_VA_OFFSET_L1(va);
    return 0;
}
```
![image](https://github.com/litterqi/operating-system/assets/123362884/32c4100d-69d7-4f2f-a162-065bb0538f6e)

![image](https://github.com/litterqi/operating-system/assets/123362884/4203713c-e6a6-4823-b37c-07cb0e0534e9)

根据提示，我们知道这个函数需要实现页表查询的功能。

具体原理如图所示：

![image](https://github.com/litterqi/operating-system/assets/123362884/d5e3e472-2745-407e-9c41-68b01d3c9bd9)

### map_range_in_pgtbl()
![image](https://github.com/litterqi/operating-system/assets/123362884/fd7cce74-5feb-45d3-8a18-29f30c9ac608)

这个函数作用是在页表中映射一段虚拟地址范围到物理地址，并设置相应的页表项属性。

```
u64 page_num = len / PAGE_SIZE + (len % PAGE_SIZE > 0);
```
计算需要映射的页数，将总长度`len`除以每页的大小`PAGE_SIZE`，并加上余数是否大于0。这样可以确定所需的页数，即`page_num`。

```
while (page_num > 0) {
    ptp_t *current_ptp = (ptp_t *)pgtbl;
    pte_t *pte;
    for (int i = 0; i < 3; ++i) {
        get_next_ptp(current_ptp, i, va, &current_ptp, &pte, true);
    }
```
![image](https://github.com/litterqi/operating-system/assets/123362884/121278b4-a8b9-4551-9303-1f965dcd04c9)
```
// l3
for (int i = GET_L3_INDEX(va); i < PTP_ENTRIES; ++i) {
    pte_t new_pte_val;
    new_pte_val.pte = 0;
    new_pte_val.l3_page.is_valid = 1;
    new_pte_val.l3_page.is_page = 1;
    new_pte_val.l3_page.pfn = pa >> PAGE_SHIFT;
    set_pte_flags(&new_pte_val, flags, USER_PTE);
    current_ptp->ent[i].pte = new_pte_val.pte;
    va += PAGE_SIZE;
    pa += PAGE_SIZE;
    --page_num;
    if (page_num == 0) {
        break;
    }
}
```
![image](https://github.com/litterqi/operating-system/assets/123362884/58744b25-e075-4309-811b-a31abbf97af0)

### unmap_range_in_pgtbl()
这个函数作用是取消页表中一段虚拟地址范围到物理地址的映射，并将相应的页表项属性设置为无效。相当于`map_range_in_pgtbl()`函数的逆过程。

```
u64 page_num = len / PAGE_SIZE + (len % PAGE_SIZE > 0);
```
计算需要取消映射的页数，与`map_range_in_pgtbl`中的计算页数的方法相同。将总长度`len`除以每页的大小`PAGE_SIZE`，并加上余数是否大于0。这样可以确定所需的页数，即`page_num`。

```
while (page_num > 0) {
    ptp_t *current_ptp = (ptp_t *)pgtbl;
    pte_t *pte;
    int res;

    res = get_next_ptp(current_ptp, 0, va, &current_ptp, &pte, false);
    if (res == -ENOMAPPING) {
        page_num -= L0_PER_ENTRY_PAGES;
        va += L0_PER_ENTRY_PAGES * PAGE_SIZE;
        continue;
    }

    res = get_next_ptp(current_ptp, 1, va, &current_ptp, &pte, false);
    if (res == -ENOMAPPING) {
        page_num -= L1_PER_ENTRY_PAGES;
        va += L1_PER_ENTRY_PAGES * PAGE_SIZE;
        continue;
    }

    res = get_next_ptp(current_ptp, 2, va, &current_ptp, &pte, false);
    if (res == -ENOMAPPING) {
        page_num -= L2_PER_ENTRY_PAGES;
        va += L2_PER_ENTRY_PAGES * PAGE_SIZE;
        continue;
    }
```

![image](https://github.com/litterqi/operating-system/assets/123362884/cb7d5487-cdda-4a21-8e9d-8481fe876adf)

```
// l3
for (int i = GET_L3_INDEX(va); i < PTP_ENTRIES; ++i) {
    current_ptp->ent[i].pte = PTE_DESCRIPTOR_INVALID;

    va += PAGE_SIZE;

    --page_num;
    if (page_num == 0) {
        break;
    }
}
```

![image](https://github.com/litterqi/operating-system/assets/123362884/440a1235-4a21-4dc3-b75c-9d31c4703b44)

练习3成功！

<img width="166" alt="58d1db406e06bde29bc93cf15d90eab" src="https://github.com/litterqi/operating-system/assets/123362884/ca7e0f9e-4b9e-4128-9a1d-f387feb4cff6">
