## 思考题1
1.权限位：页表项中可以设置权限位，如读、写、执行等。通过设置适当的权限位，可以控制进程对内存区域的访问权限，确保只有被授权的操作可以执行。

2.存在位：页表项还会有一个存在位（Present/Absent bit）来表示该虚拟页面是否已经被加载到物理内存中。如果一个进程试图访问一个不存在的页面，操作系统会收到一个页面错误（Page Fault），然后它可以选择从磁盘中加载该页面到物理内存中，这就实现了按需加载。

3.修改位和访问位：修改位（Dirty bit）用来表示页面是否被修改过，访问位（Accessed bit）用来表示页面是否被访问过。这两个位可以帮助操作系统做出更好的页面替换决策。
虚拟内存映射：页表项可以映射虚拟地址到物理地址。通过设置不同的映射关系，可以将进程所需的内存按需加载到物理内存中。这样，进程只需访问当前需要的页面，而不需要一次性加载整个程序或数据集。

4.页面置换算法：对于物理内存空间有限的情况，可以使用页面置换算法（如最近最少使用算法或时钟算法）来管理物理内存中的页面。当内存不足时，会根据一定的策略将不再需要的页面置换出去，腾出空间给新的页面加载进来。

5.内存保护：通过页表项，可以实现内存的保护功能。例如，使用页表项中的保护位可以将某些内存区域标记为只读或禁止执行，从而防止进程进行非法的修改或执行操作。

6.分页机制：分页机制可以将进程的地址空间划分为多个固定大小的页面，并通过页表来映射这些页面到物理内存。这种方式可以提高内存利用率，同时也可以实现内存的隔离和保护。

优势：

内存空间利用率高：多级页表可以有效地利用内存空间。在单级页表中，整个地址空间的页表项都需要存在，无论哪个地址是否被使用。而多级页表通过按需加载页表项，只加载当前需要的部分，大大节省了内存资源。

地址映射快速：多级页表可以通过层级化的结构，快速定位到所需的页表项，从而加快地址映射的速度。相比之下，单级页表需要遍历整个页表才能找到对应的页表项。

灵活性：多级页表可以根据实际需求进行动态调整。例如，可以增加或减少不同层级的页表项数量来适应不同进程的需求，从而提高系统的灵活性。

劣势：

访问延迟增加：由于多级页表需要多次访问内存才能完成地址映射，所以相对于单级页表，多级页表的访问延迟会增加一些。这是因为在多级页表中，需要首先访问顶级页表，然后再逐级访问下一级页表，直到找到所需的页表项。

空间开销增加：为了支持多级页表，需要额外存储多个层级的页表结构。这会带来一定的空间开销。在内存有限的情况下，多级页表可能会占用较多的内存资源。

需要根据具体的情况和需求来权衡使用单级页表还是多级页表。当系统对内存空间利用率和地址映射速度有较高要求时，多级页表可以提供更好的性能。而在内存资源较为紧缺或者对访问延迟要求较低的情况下，单级页表可能更适合。

## 思考题2
1.UXN（User eXecute Never）：此位用于控制用户模式下是否可以执行该页中的代码。如果UXN位被设置，那么在用户模式下，任何尝试执行该页中的代码的操作都将触发异常。

2.PXN（Privileged eXecute Never）：此位用于控制特权模式下是否可以执行该页中的代码。如果PXN位被设置，那么在特权模式下，任何尝试执行该页中的代码的操作都将触发异常。

3.AF（Accessed Flag）：此位用于表示该页是否被访问过。当一个页被访问时，硬件会自动将AF位设置为1。

4.AP（Access Permission）：这是一组位，用于控制对该页的访问权限。例如，它可以用来控制该页是否可写，是否只能在特权模式下访问等。

参考资料：

https://github.com/codingbelief/arm-architecture-reference-manual-for-armv8-a/blob/master/en/chapter_d4/d43_3_memory_attribute_fields_in_the_vmsav8-64_translation_table_formats_descriptors.md

https://stackoverflow.com/questions/21546541/x86-dirty-bit-in-page-table-entry

https://www.geeksforgeeks.org/page-table-entries-in-page-table/

## 选做题1
对于2MB的大页，如果我们假设系统使用48位的虚拟地址空间，那么地址划分可能如下：

9位用于第一级页表（PML4）

9位用于第二级页表（PDPT）

9位用于第三级页表（PDT）

21位用于偏移量

对于1GB的大页，地址划分可能如下：

9位用于第一级页表（PML4）

9位用于第二级页表（PDPT）

30位用于偏移量

优点：

减少TLB缺失：由于每个TLB条目可以映射更大的内存区域，因此使用大页可以减少TLB缺失，从而提高内存访问性能。

减少内存管理开销：使用大页可以减少页表项的数量，从而减少内存管理的开销。

缺点：

内部碎片：如果一个进程只需要使用大页中的一小部分内存，那么剩余的内存就会被浪费，这就是所谓的内部碎片。

增加了内存使用量：由于每个大页都占用较大的连续物理内存空间，因此使用大页可能会增加总体的内存使用量。

## 选做题2
伙伴系统是一种基于二叉树的内存管理算法，它将物理内存分成大小相等的块，并以2的幂次为单位进行分配。当一个请求到来时，伙伴系统会将最接近请求大小的2的幂次大小的块分配给请求者，如果有剩余，则将其拆分成更小的块，直到满足请求为止。而释放内存时则会将相邻的空闲块合并成更大的块，直到合并到最大的块为止。

相比之下，SLAB分配器则是一种更高效的内存管理算法，它通过预先分配一些固定大小的内存块（称为slab），并使用一个对象缓存来管理这些内存块。当需要分配内存时，SLAB分配器会从对象缓存中查找是否有可用的slab，如果有，则从其中分配一部分内存给请求者。而当释放内存时，SLAB分配器会将该内存块返回给对象缓存，以便下次分配时可以直接使用。

与伙伴系统相比，SLAB分配器具有以下优点：

更高的性能：由于SLAB分配器预先分配了一些内存块，并使用对象缓存来管理这些内存块，因此在分配和释放内存时不需要频繁地进行内存合并和拆分操作，从而提高了性能。

更灵活的内存管理：SLAB分配器可以根据应用程序的需求预先分配一些内存块，并将它们存储在对象缓存中，以便下次分配时可以直接使用。这种方式可以避免频繁地进行内存合并和拆分操作，从而提高了内存管理的灵活性。

更好的可扩展性：由于SLAB分配器可以为每个对象类型分配一个单独的对象缓存，因此可以更好地支持多线程和多CPU的系统。

在Linux内核中，伙伴系统和SLAB分配器是共同管理内存空间的。当需要分配内存时，内核会首先尝试使用SLAB分配器来分配内存，如果SLAB分配器无法满足请求，则会使用伙伴系统来分配内存。而当释放内存时，内核会将内存块返回给相应的内存管理器（即SLAB分配器或伙伴系统），以便下次分配时可以直接使用。

## 选做题3
在Linux 2.6中，内核启动页表的初始化是通过start_kernel()函数中的paging_init()函数完成的。具体来说，该函数会执行以下步骤：

调用setup_arch()函数来设置架构相关的信息，包括物理内存大小、虚拟地址空间大小等。

调用mem_init()函数来初始化物理内存管理器，包括建立物理内存映射和分配内核代码和数据的物理内存。

调用paging_init()函数来初始化内核启动页表，该函数定义在arch/x86/mm/init.c文件中。具体来说，该函数会执行以下步骤：

a. 调用early_ioremap_init()函数来建立内核启动阶段需要使用的I/O映射。

b. 调用identity_mapping_init()函数来建立一段大小为1GB的虚拟地址空间，用于映射物理内存的前1GB地址空间。

c. 调用pgtable_early_init()函数来初始化内核页表，包括建立L0、L1和L2级页表，并将其映射到对应的物理地址上。

d. 调用initmem_init()函数来初始化内核代码和数据所在的物理内存区域，包括建立相应的页表映射关系。

e. 调用paging_enable()函数来启用分页机制，将CR0寄存器中的PG位设置为1。

最后，调用rest_init()函数来初始化系统的剩余部分，包括进程管理、中断管理等。

在Linux 2.6中，L0、L1和L2级页表页并没有静态地分配好，而是在pgtable_early_init()函数中动态地分配的。该函数会调用pgd_alloc()函数来分配一级页表，然后再调用pmd_alloc()函数和pte_alloc()函数来分配二级页表和三级页表。最后，将三级页表页映射到对应的物理地址上，完成页表的初始化。
