## 1.首先是喜闻乐见的代码解读部分：
### 预定义变量和宏：
(`init_boot_pt()`函数位于oslab2\kernel\arch\aarch64\boot\raspi3\init\mmu.c中)

```
/* Physical memory address space: 0-1G */
#define PHYSMEM_START   (0x0UL)
#define PERIPHERAL_BASE (0x3F000000UL)
#define PHYSMEM_END     (0x40000000UL)
```
![image](https://github.com/litterqi/operating-system/assets/123362884/c38d707f-4a66-4022-be07-76939b232406)

地址末尾的"UL"是C/C++语言中的后缀，表示无符号长整型（unsigned long）。

```
#define ALIGN(n) __attribute__((__aligned__(n)))
u64 boot_ttbr0_l0[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr0_l1[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr0_l2[PTP_ENTRIES] ALIGN(PTP_SIZE);

u64 boot_ttbr1_l0[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr1_l1[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr1_l2[PTP_ENTRIES] ALIGN(PTP_SIZE);
```
![image](https://github.com/litterqi/operating-system/assets/123362884/84eb208c-af85-45e0-b131-2fcddc1207d9)

其中`PTP_ENTRIES`,`PTP_SIZE`分别表示页表中每一页的页表项数和每一页的大小。

![image](https://github.com/litterqi/operating-system/assets/123362884/35ca299e-b27b-41b5-babc-526c48bffb58)

```
#define IS_VALID (1UL << 0)
#define IS_TABLE (1UL << 1)

#define UXN            (0x1UL << 54)
#define ACCESSED       (0x1UL << 10)
#define NG             (0x1UL << 11)
#define INNER_SHARABLE (0x3UL << 8)
#define NORMAL_MEMORY  (0x0UL << 2)
#define DEVICE_MEMORY  (0x1UL << 2)
```
![image](https://github.com/litterqi/operating-system/assets/123362884/3df85407-bccd-40e6-9e0c-53f900d1096e)

由ppt可知，这些常量全部都是页表项中的某一位或某几位。

![image](https://github.com/litterqi/operating-system/assets/123362884/1319415a-40bc-4fe5-b182-1e73f718df9c)
![image](https://github.com/litterqi/operating-system/assets/123362884/9d8c82ed-3212-4b6f-9aca-2c4b203b5105)

```
#define SIZE_2M (2UL * 1024 * 1024)

#define GET_L0_INDEX(x) (((x) >> (12 + 9 + 9 + 9)) & 0x1ff)
#define GET_L1_INDEX(x) (((x) >> (12 + 9 + 9)) & 0x1ff)
#define GET_L2_INDEX(x) (((x) >> (12 + 9)) & 0x1ff)
```
![image](https://github.com/litterqi/operating-system/assets/123362884/8e59bd7d-6ccf-4442-82f1-ae115cbc41a5)

`SIZE_2M`代表2MB的大小，用于指定内存页的大小。L0,L1,L2代表多级页表中的第0，1，2级。
### 进入`init_boot_pt()`函数中：
```
u64 vaddr = PHYSMEM_START;

        /* TTBR0_EL1 0-1G */
        boot_ttbr0_l0[GET_L0_INDEX(vaddr)] = ((u64)boot_ttbr0_l1) | IS_TABLE
                                             | IS_VALID | NG;
        boot_ttbr0_l1[GET_L1_INDEX(vaddr)] = ((u64)boot_ttbr0_l2) | IS_TABLE
                                             | IS_VALID | NG;
```

![image](https://github.com/litterqi/operating-system/assets/123362884/46385001-c529-4572-9e89-3d114bc1422a)

这段代码的作用是使每级页表的起始位置指向下一级页表的起始位置。`GET_L0_INDEX()`,`GET_L1_INDEX()`函数用来获取L0,L1页表的起始地址。

![image](https://github.com/litterqi/operating-system/assets/123362884/191f6d8c-6b90-47c5-baa8-2fdde0c3e623)

```
/* Normal memory: PHYSMEM_START ~ PERIPHERAL_BASE */
        for (; vaddr < PERIPHERAL_BASE; vaddr += SIZE_2M) {
                boot_ttbr0_l2[GET_L2_INDEX(vaddr)] =
                        (vaddr) /* low mem, va = pa */
                        | UXN /* Unprivileged execute never */
                        | ACCESSED /* Set access flag */
                        | NG /* Mark as not global */
                        | INNER_SHARABLE /* Sharebility */
                        | NORMAL_MEMORY /* Normal memory */
                        | IS_VALID;
        }
```

