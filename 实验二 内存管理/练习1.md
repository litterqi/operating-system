## 1.首先是喜闻乐见的代码解读部分：
### 预定义变量和宏：
(`init_boot_pt()`函数位于oslab2\kernel\arch\aarch64\boot\raspi3\init\mmu.c中)

```
/* Physical memory address space: 0-1G */
#define PHYSMEM_START   (0x0UL)
#define PERIPHERAL_BASE (0x3F000000UL)
#define PHYSMEM_END     (0x40000000UL)
```
![image](https://github.com/litterqi/operating-system/assets/123362884/c38d707f-4a66-4022-be07-76939b232406)

地址末尾的"UL"是C/C++语言中的后缀，表示无符号长整型（unsigned long）。

```
#define ALIGN(n) __attribute__((__aligned__(n)))
u64 boot_ttbr0_l0[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr0_l1[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr0_l2[PTP_ENTRIES] ALIGN(PTP_SIZE);

u64 boot_ttbr1_l0[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr1_l1[PTP_ENTRIES] ALIGN(PTP_SIZE);
u64 boot_ttbr1_l2[PTP_ENTRIES] ALIGN(PTP_SIZE);
```
![image](https://github.com/litterqi/operating-system/assets/123362884/84eb208c-af85-45e0-b131-2fcddc1207d9)

其中`PTP_ENTRIES`,`PTP_SIZE`分别表示页表中每一页的页表项数和每一页的大小。

![image](https://github.com/litterqi/operating-system/assets/123362884/35ca299e-b27b-41b5-babc-526c48bffb58)

```
#define IS_VALID (1UL << 0)
#define IS_TABLE (1UL << 1)

#define UXN            (0x1UL << 54)
#define ACCESSED       (0x1UL << 10)
#define NG             (0x1UL << 11)
#define INNER_SHARABLE (0x3UL << 8)
#define NORMAL_MEMORY  (0x0UL << 2)
#define DEVICE_MEMORY  (0x1UL << 2)
```
![image](https://github.com/litterqi/operating-system/assets/123362884/3df85407-bccd-40e6-9e0c-53f900d1096e)

由ppt可知，这些常量全部都是页表项中的某一位或某几位。

![image](https://github.com/litterqi/operating-system/assets/123362884/1319415a-40bc-4fe5-b182-1e73f718df9c)
![image](https://github.com/litterqi/operating-system/assets/123362884/9d8c82ed-3212-4b6f-9aca-2c4b203b5105)

```
#define SIZE_2M (2UL * 1024 * 1024)

#define GET_L0_INDEX(x) (((x) >> (12 + 9 + 9 + 9)) & 0x1ff)
#define GET_L1_INDEX(x) (((x) >> (12 + 9 + 9)) & 0x1ff)
#define GET_L2_INDEX(x) (((x) >> (12 + 9)) & 0x1ff)
```
![image](https://github.com/litterqi/operating-system/assets/123362884/8e59bd7d-6ccf-4442-82f1-ae115cbc41a5)

`SIZE_2M`代表2MB的大小，用于指定内存页的大小。L0,L1,L2代表多级页表中的第0，1，2级。
### 进入`init_boot_pt()`函数中：
```
u64 vaddr = PHYSMEM_START;

        /* TTBR0_EL1 0-1G */
        boot_ttbr0_l0[GET_L0_INDEX(vaddr)] = ((u64)boot_ttbr0_l1) | IS_TABLE
                                             | IS_VALID | NG;
        boot_ttbr0_l1[GET_L1_INDEX(vaddr)] = ((u64)boot_ttbr0_l2) | IS_TABLE
                                             | IS_VALID | NG;
```

![image](https://github.com/litterqi/operating-system/assets/123362884/46385001-c529-4572-9e89-3d114bc1422a)

这段代码的作用是使每级页表的起始位置指向下一级页表的起始位置。`GET_L0_INDEX(vaddr)`,`GET_L1_INDEX(vaddr)`函数用来获取L0,L1页表的起始地址。

![image](https://github.com/litterqi/operating-system/assets/123362884/191f6d8c-6b90-47c5-baa8-2fdde0c3e623)

```
/* Normal memory: PHYSMEM_START ~ PERIPHERAL_BASE */
        for (; vaddr < PERIPHERAL_BASE; vaddr += SIZE_2M) {
                boot_ttbr0_l2[GET_L2_INDEX(vaddr)] =
                        (vaddr) /* low mem, va = pa */
                        | UXN /* Unprivileged execute never */
                        | ACCESSED /* Set access flag */
                        | NG /* Mark as not global */
                        | INNER_SHARABLE /* Sharebility */
                        | NORMAL_MEMORY /* Normal memory */
                        | IS_VALID;
        }
```

![image](https://github.com/litterqi/operating-system/assets/123362884/be10ee6f-3135-4ec1-9636-5ed5113ad71f)

```
/* Peripheral memory: PERIPHERAL_BASE ~ PHYSMEM_END */
        for (vaddr = PERIPHERAL_BASE; vaddr < PHYSMEM_END; vaddr += SIZE_2M) {
                boot_ttbr0_l2[GET_L2_INDEX(vaddr)] =
                        (vaddr) /* low mem, va = pa */
                        | UXN /* Unprivileged execute never */
                        | ACCESSED /* Set access flag */
                        | NG /* Mark as not global */
                        | DEVICE_MEMORY /* Device memory */
                        | IS_VALID;
        }
```

![image](https://github.com/litterqi/operating-system/assets/123362884/b0d6df34-cc85-4b14-8db6-b229a4d3dea9)

以上两部分代码作用如图所示。

![image](https://github.com/litterqi/operating-system/assets/123362884/d4d5ca8d-1351-4e03-8a46-ab297a611aa6)

```
vaddr = KERNEL_VADDR + PHYSMEM_END;
        boot_ttbr1_l1[GET_L1_INDEX(vaddr)] = PHYSMEM_END | UXN /* Unprivileged
                                                                  execute never
                                                                */
                                             | ACCESSED /* Set access flag */
                                             | NG /* Mark as not global */
                                             | DEVICE_MEMORY /* Device memory */
                                             | IS_VALID;
```

![image](https://github.com/litterqi/operating-system/assets/123362884/5ce5c267-36fd-45cd-afb6-12992f434678)

内核代码的高地址空间开始位置存储在宏 KERNEL_VADDR 中。

为什么`KERNEL_VADDR + PHYSMEM_END`是内核虚拟地址空间中与物理地址 PHYSMEM_END 对应的虚拟地址呢？如ppt中所写：
 
![image](https://github.com/litterqi/operating-system/assets/123362884/65af812f-e38d-441e-b874-8c533a63df60)
![image](https://github.com/litterqi/operating-system/assets/123362884/72e1797d-1a4f-4207-877f-366dbcbe3bb7)

## 2.答案解读：
答案部分实现了内核高地址页表映射，代码与第一部分差别很小。

```
/* Step 1: set L0 and L1 page table entry */
        vaddr = KERNEL_VADDR + PHYSMEM_START;
        boot_ttbr1_l0[GET_L0_INDEX(vaddr)] = ((u64)boot_ttbr1_l1) | IS_TABLE
                                             | IS_VALID | NG;
        boot_ttbr1_l1[GET_L1_INDEX(vaddr)] = ((u64)boot_ttbr1_l2) | IS_TABLE
                                             | IS_VALID | NG;
```
![image](https://github.com/litterqi/operating-system/assets/123362884/614ae82f-0d1f-4fd0-bc94-17ff484700ed)

```
/* Step 2: map PHYSMEM_START ~ PERIPHERAL_BASE with 2MB granularity */
        for (vaddr = KERNEL_VADDR + PHYSMEM_START; vaddr < KERNEL_VADDR + PERIPHERAL_BASE; vaddr += SIZE_2M) {
                boot_ttbr1_l2[GET_L2_INDEX(vaddr)] =
                        (vaddr - KERNEL_VADDR)
                        | UXN /* Unprivileged execute never */
                        | ACCESSED /* Set access flag */
                        | NG /* Mark as not global */
                        | INNER_SHARABLE /* Sharebility */
                        | NORMAL_MEMORY /* Normal memory */
                        | IS_VALID;
        }
```
![image](https://github.com/litterqi/operating-system/assets/123362884/f5472d3a-6f25-459f-8a51-06771c0fbe26)

```
/* Step 2: map PERIPHERAL_BASE ~ PHYSMEM_END with 2MB granularity */
        for (vaddr = KERNEL_VADDR + PERIPHERAL_BASE; vaddr < KERNEL_VADDR + PHYSMEM_END; vaddr += SIZE_2M) {
                boot_ttbr1_l2[GET_L2_INDEX(vaddr)] =
                        (vaddr - KERNEL_VADDR)
                        | UXN /* Unprivileged execute never */
                        | ACCESSED /* Set access flag */
                        | NG /* Mark as not global */
                        | DEVICE_MEMORY /* Device memory */
                        | IS_VALID;
        }
```
![image](https://github.com/litterqi/operating-system/assets/123362884/4f355f6e-8246-467a-adb3-76c5c6abc893)

练习1成功！

![image](https://github.com/litterqi/operating-system/assets/123362884/0819ef6a-1202-402e-bbda-9034dd826145)
