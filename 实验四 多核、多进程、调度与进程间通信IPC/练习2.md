# 答案解读：
所需函数位于oslab4\kernel\arch\aarch64\sync\ticket.c中
## unlock()
```
++lock->owner;
```
这行代码将锁的所有者(owner)加1，即解锁该锁。

为什么：

![image](https://github.com/litterqi/operating-system/assets/123362884/49a874de-6c74-4889-9270-6f16f8875483)

由ppt可知，该内核锁的原理是排号锁，每一个进程顺序取号，所以将owner加1相当于把锁传递给下一个进程。
## is_locked()
```
ret =(lock->owner < lock->next);
```
该表达式通过比较锁的owner和next字段的值来判断锁的状态。如果owner的值小于next的值，那么返回值ret被设为1，表示锁被锁住；否则返回值ret为0，表示锁没有被锁住。

为什么：

![image](https://github.com/litterqi/operating-system/assets/123362884/58af3fe2-244f-4305-b33d-cc3c6ce8692b)

在`try_lock()`函数中，代码使用内联汇编（asm）的方式，嵌入了一段汇编代码。这段汇编代码实现了尝试加锁的过程，包括以下主要步骤：

使用原子操作 ldaxr 和 ldar 分别加载 lock->next 和 lock->owner 的值，并将结果存储在 lockval 和 ownerval 中。

将 lockval 的值增加1，并将结果存储在 newval 中。

比较 lockval 和 ownerval 的值，如果二者不相等，跳转到标签 2f，表示加锁失败。

使用原子操作 stxr 尝试将 newval 存储到 lock->next 中，并将操作结果存储在 ret 中。如果存储操作失败，则跳转到标签 1b，重新尝试。

如果存储操作成功（即 ret 为0），将 ret 的值设为0，表示加锁成功。

这段汇编代码从反面说明了当`lock->owner < lock->next`时锁是锁住的。
## kernel_lock_init()
```
ret = lock_init(&big_kernel_lock);
```
这行代码调用`lock_init()`函数，传递上面定义的big_kernel_lock结构体作为参数，并将返回值传给变量ret。`lock_init()`函数的作用是初始化一个内核锁，使其处于可用状态。
## lock_kernel()
```
lock(&big_kernel_lock);
```
由注释可知，这里需要获取大内核锁。调用`lock()`函数，并将big_kernel_lock作为参数传给它。`lock()`函数实现了一个基于原子操作的锁，用于保护共享资源，确保在多线程环境下对资源的访问是互斥的。
## unlock_kernel()
```
unlock(&big_kernel_lock);
```
由注释可知，这里需要释放大内核锁。调用`unlock()`函数，并将big_kernel_lock作为参数传给它。`unlock()`函数用于解锁。
## 调用lock_kernel()与unlock_kernel()
![image](https://github.com/litterqi/operating-system/assets/123362884/a2793519-0464-48fb-bd74-718850063c7c)

根据ppt所给提示和代码中的`LAB4 TODO`，我们在创建根进程前、其他进程开始调度前以及处理终端等位置需要上大内核锁，而解锁则只需要在处理完异常返回时即可。我们需要在以下位置添加`lock_kernel()`与`unlock_kernel()`调用：
### kernel/arch/aarch64/main.c
`main()`函数：

```
#ifdef CHCORE_KERNEL_TEST
	run_test();
#endif
	lock_kernel();
```

`secondary_start()`函数：

```
#ifdef CHCORE_KERNEL_TEST
	run_test();
#endif
	lock_kernel();
```
### kernel/arch/aarch64/irq/irq_entry.S
`sync_el0_64`：

```
bl unlock_kernel
```

`el0_syscall`：

```
bl lock_kernel
```
```
bl unlock_kernel
```
### kernel/arch/aarch64/irq/irq_entry.c
`handle_entry_c()`：

```
if (type >= SYNC_EL0_64)
        lock_kernel();
```
检查异常类型type是否属于内核级别及以上异常。如果type大于等于SYNC_EL0_64(SYNC_EL0_64 表示在用户空间(EL0)发生的同步异常)，那么表示异常来自于用户模式的EL0级别及以上，需要获取大内核锁。

`handle_irq()`：

```
if (type >= SYNC_EL0_64 || current_thread->thread_ctx->type == TYPE_IDLE)
{
    	lock_kernel();
}
```
检查异常类型type是否大于等于SYNC_EL0_64，或者当前被中断的线程是否为一个空闲线程(idle thread)。如果满足其中任一条件，就需要获取大内核锁。

空闲线程（idle thread）是指在操作系统中用于处理空闲时间的特殊线程。当系统中没有其他需要执行的任务时，空闲线程会被调度运行。空闲线程通常是一个非常简单的线程，它的主要目的是占用 CPU 时间，以防止系统陷入无限循环或浪费资源的状态。空闲线程可以执行一些轻量级的任务，如等待计时器中断或检查是否有新的任务需要运行。通过使用空闲线程，操作系统可以充分利用 CPU 资源，并确保即使在没有其他任务需要执行时，系统仍保持活跃和响应。空闲线程还可以执行一些系统维护任务，如更新系统状态、清理内存或监测硬件设备。
