# 答案解读：
所需函数位于oslab4\kernel\arch\aarch64\sync\ticket.c中
## unlock()
```
++lock->owner;
```
这行代码将锁的所有者(owner)加1，即解锁该锁。

为什么：

![image](https://github.com/litterqi/operating-system/assets/123362884/49a874de-6c74-4889-9270-6f16f8875483)

由ppt可知，该内核锁的原理是排号锁，每一个进程顺序取号，所以将owner加1相当于把锁传递给下一个进程。
## is_locked()
```
ret =(lock->owner < lock->next);
```
该表达式通过比较锁的owner和next字段的值来判断锁的状态。如果owner的值小于next的值，那么返回值ret被设为1，表示锁被锁住；否则返回值ret为0，表示锁没有被锁住。

为什么：

![image](https://github.com/litterqi/operating-system/assets/123362884/58af3fe2-244f-4305-b33d-cc3c6ce8692b)

在`try_lock()`函数中，代码使用内联汇编（asm）的方式，嵌入了一段汇编代码。这段汇编代码实现了尝试加锁的过程，包括以下主要步骤：

使用原子操作 ldaxr 和 ldar 分别加载 lock->next 和 lock->owner 的值，并将结果存储在 lockval 和 ownerval 中。

将 lockval 的值增加1，并将结果存储在 newval 中。

比较 lockval 和 ownerval 的值，如果二者不相等，跳转到标签 2f，表示加锁失败。

使用原子操作 stxr 尝试将 newval 存储到 lock->next 中，并将操作结果存储在 ret 中。如果存储操作失败，则跳转到标签 1b，重新尝试。

如果存储操作成功（即 ret 为0），将 ret 的值设为0，表示加锁成功。

这段汇编代码从反面说明了当`lock->owner < lock->next`时锁是锁住的。
## kernel_lock_init()
```
ret = lock_init(&big_kernel_lock);
```

## lock_kernel()
```
lock(&big_kernel_lock);
```

## unlock_kernel()
```
unlock(&big_kernel_lock);
```
