# 答案解读：
相关函数位于oslab4\libchcore\src\ipc\ipc.c中
## ipc_register_server()
```
vm_config.buf_base_addr = SERVER_BUF_BASE;
vm_config.buf_size = SERVER_BUF_SIZE;
vm_config.stack_base_addr = SERVER_STACK_BASE;
vm_config.stack_size = SERVER_STACK_SIZE;
```
## ipc_register_client()
```
vm_config.buf_base_addr = CLIENT_BUF_BASE + client_id * CLIENT_BUF_SIZE;
vm_config.buf_size = CLIENT_BUF_SIZE;
```
## ipc_set_msg_data()
```
memcpy(ipc_get_msg_data(ipc_msg) + offset, data, len);
```

相关函数位于oslab4\kernel\ipc\connection.c中
## create_connection()
```
server_stack_base = vm_config->stack_base_addr + conn_idx * vm_config->stack_size;
```
```
server_buf_base = vm_config->buf_base_addr + conn_idx * vm_config->buf_size;
client_buf_base = client_vm_config->buf_base_addr;
```
```
vmspace_map_range(current_thread->vmspace, client_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);
vmspace_map_range(target->vmspace, server_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);
```
## thread_migrate_to_server()
```
arch_set_thread_stack(target, conn->server_stack_top);
```
```
arch_set_thread_next_ip(target, callback);
```
```
arch_set_thread_arg0(target, arg);
arch_set_thread_arg1(target, current_thread->cap_group->pid);
```
## thread_migrate_to_client()
```
arch_set_thread_return(source, ret_value);
```
## ipc_send_cap()
```
dest_cap = cap_copy(current_cap_group, conn->target->cap_group, cap_buf[i]);
if (dest_cap < 0)
  goto out_free_cap;
cap_buf[i] = dest_cap;
```
## sys_ipc_return()
```
conn->source->thread_ctx->state = TS_RUNNING;
conn->source->thread_ctx->sc = current_thread->thread_ctx->sc;
```
## sys_ipc_call()
```
if (cap_num > 0)
{
  r = ipc_send_cap(conn);
  if (r < 0)
    goto out_obj_put;
}
```
```
arg = conn->buf.server_user_addr;
```
