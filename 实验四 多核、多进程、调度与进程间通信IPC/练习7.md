# 答案解读：
相关函数位于oslab4\libchcore\src\ipc\ipc.c中
## ipc_register_server()
```
vm_config.buf_base_addr = SERVER_BUF_BASE;
vm_config.buf_size = SERVER_BUF_SIZE;
vm_config.stack_base_addr = SERVER_STACK_BASE;
vm_config.stack_size = SERVER_STACK_SIZE;
```
这部分代码对vm_config结构体中的成员变量buf_base_addr、buf_size、stack_base_addr和stack_size进行了初始化，分别表示服务器缓冲区的基地址、大小，以及栈的基地址和大小。其中所用到的宏定义在ChCore/libchcore/include/chcore/ipc.h中。

![image](https://github.com/litterqi/operating-system/assets/123362884/b94c80be-22df-4f67-b036-1a5035f6fb4a)
## ipc_register_client()
```
vm_config.buf_base_addr = CLIENT_BUF_BASE + client_id * CLIENT_BUF_SIZE;
vm_config.buf_size = CLIENT_BUF_SIZE;
```
根据注释，这部分代码是根据客户端ID(client_id)来填充vm_config结构体变量。首先根据客户端的ID计算出缓冲区基地址(buf_base_addr)，通过将`CLIENT_BUF_BASE`宏与`client_id*CLIENT_BUF_SIZE`相加得到，这样每个客户端都会有一个唯一的缓冲区基地址。然后设置缓冲区的大小(buf_size)为CLIENT_BUF_SIZE宏，表示每个客户端缓冲区的大小。
## ipc_set_msg_data()
```
memcpy(ipc_get_msg_data(ipc_msg) + offset, data, len);
```
根据注释要求，这行代码需要将源数据data拷贝到IPC消息结构体ipc_msg数据部分中的指定偏移处。调用`ipc_get_msg_data(ipc_msg)`返回指向IPC消息数据部分的指针，再通过`ipc_get_msg_data(ipc_msg) + offset`计算出目标位置的偏移量，也就是数据开始拷贝的位置。最后使用`memcpy()`函数进行数据的拷贝。

相关函数位于oslab4\kernel\ipc\connection.c中
## create_connection()
```
server_stack_base = vm_config->stack_base_addr + conn_idx * vm_config->stack_size;
```
根据注释，这行代码需要设置服务器线程栈空间的基地址server_stack_base。`vm_config->stack_base_addr`是服务器线程栈空间的起始地址。conn_idx是当前连接的索引，用于区分不同的连接，通过乘以`vm_config->stack_size`(表示每个线程栈的大小)，可以确定当前连接对应的线程栈空间的偏移量。
```
server_buf_base = vm_config->buf_base_addr + conn_idx * vm_config->buf_size;
client_buf_base = client_vm_config->buf_base_addr;
```
根据注释，这段代码需要设置客户端和服务器端共享缓冲区的基地址。

`vm_config->buf_base_addr`是服务器端共享缓冲区的起始地址。conn_idx是当前连接的索引，用于区分不同的连接，通过乘以`vm_config->buf_size`(表示每个连接共享缓冲区的大小)，可以确定当前连接对应的共享缓冲区的偏移量，即得到了当前连接对应的服务器端共享缓冲区的基地址。

`client_vm_config->buf_base_addr`是客户端共享缓冲区的起始地址。
```
vmspace_map_range(current_thread->vmspace, client_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);
vmspace_map_range(target->vmspace, server_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);
```
根据注释，这段代码需要将物理内存对象buf_pmo映射到客户端和服务器线程的虚拟内存空间中。通过调用`vmspace_map_range()`函数来实现(`vmspace_map_range()`(ChCore/kernel/mm/vmregion.c)的作用是在指定的虚拟内存空间中映射一段物理内存)。其中current_thread->vmspace(target->vmspace)是当前线程(目标服务器线程)的虚拟内存空间。client_buf_base是客户端(服务器端)共享缓冲区的起始地址。buf_size是共享缓冲区的大小。VMR_READ | VMR_WRITE表示对共享缓冲区的映射权限，即可读可写。buf_pmo是之前分配的物理内存对象结构体指针。
## thread_migrate_to_server()
```
arch_set_thread_stack(target, conn->server_stack_top);
```
这段代码中的注释说明了要使用arch_set_thread_stack函数来设置目标线程的栈指针(sp寄存器)。
```
arch_set_thread_next_ip(target, callback);
```
根据注释，这行代码需要设置目标线程的下一条指令地址(ip寄存器)。callback是从目标线程的通用IPC配置中获取的回调函数地址。通过将这个地址传递给`arch_set_thread_next_ip()`函数，代码确保了在切换到目标线程后，目标线程将会执行这个回调函数。
```
arch_set_thread_arg0(target, arg);
arch_set_thread_arg1(target, current_thread->cap_group->pid);
```
根据注释，这部分代码需要使用`arch_set_thread_arg0/1()`函数来设置目标线程的参数。通过调用`arch_set_thread_arg0()`函数，将arg的值设置为目标线程的第一个参数。而调用 `arch_set_thread_arg1()`函数，将`current_thread->cap_group->pid`的值设置为目标线程的第二个参数。
## thread_migrate_to_client()
```
arch_set_thread_return(source, ret_value);
```
根据注释，这行代码用于设置服务器线程的返回值。调用`arch_set_thread_return()`函数，将ret_value的值设置为source线程的返回值。
## ipc_send_cap()
```
dest_cap = cap_copy(current_cap_group, conn->target->cap_group, cap_buf[i]);
if (dest_cap < 0)
  goto out_free_cap;
cap_buf[i] = dest_cap;
```
根据注释，这部分代码需要遍历每个能力并将其复制到服务器端的能力组中，然后更新cap_buf中对应位置的能力副本。调用`cap_copy()`函数，该函数的作用是将当前线程的能力从current_cap_group复制到conn->target->cap_group，并返回复制后的副本的句柄。cap_buf[i]中保存的是当前线程的能力，通过`cap_copy()`函数将其复制到服务器线程的能力组中，然后将复制后的副本句柄保存到dest_cap变量中。如果复制操作失败(即返回值小于0)，则跳转到 out_free_cap 标签处进行错误处理。将dest_cap赋值给cap_buf[i]，即更新了cap_buf中对应位置的能力副本。
## sys_ipc_return()
```
conn->source->thread_ctx->state = TS_RUNNING;
conn->source->thread_ctx->sc = current_thread->thread_ctx->sc;
```
根据注释，这部分代码需要更新线程状态和系统调用号。通过访问源连接的线程上下文结构体，即conn->source->thread_ctx，将其中的state字段设置为TS_RUNNING，表示线程已经恢复运行。然后将sc 字段设置为当前线程的系统调用号，即current_thread->thread_ctx->sc。
## sys_ipc_call()
```
if (cap_num > 0)
{
  r = ipc_send_cap(conn);
  if (r < 0)
    goto out_obj_put;
}
```
根据注释，这段代码的作用是在满足条件cap_num>0时调用`ipc_send_cap()`函数，将客户端线程的能力传递给服务器线程。首先通过条件判断`if(cap_num>0)`来检查cap_num是否大于0，如果条件成立就会调用`ipc_send_cap()`函数，并将conn作为参数传递给该函数。`ipc_send_cap()`函数的作用是将客户端线程的能力传递给服务器线程。然后，检查返回值r是否小于0，如果返回值小于0，表示能力传递操作出现了错误，此时会跳转到标签out_obj_put处进行相应的处理。
```
arg = conn->buf.server_user_addr;
```
根据注释，这部分代码需要需要设置arg的值。通过把conn->buf.server_user_addr赋给arg，即将服务器端用户地址作为参数值传递给`ipc_dispatcher()`函数。
