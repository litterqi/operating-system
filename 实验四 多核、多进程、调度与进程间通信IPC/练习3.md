# 答案解读：
函数位于oslab4\kernel\sched\policy_rr.c中
## rr_sched_enqueue()
```
if (thread == NULL || thread->thread_ctx == NULL || thread->thread_ctx->state == TS_READY) {
                return -EINVAL;
        }
        if (thread->thread_ctx->type == TYPE_IDLE) {
                return 0;
        }
        u32 cpu_id;
        cpu_id = smp_get_cpu_id();
        if (cpu_id >= PLAT_CPU_NUM)
                return -EINVAL;
        thread->thread_ctx->state = TS_READY;
        thread->thread_ctx->cpuid = cpu_id;
        list_append(&(thread->ready_queue_node), &(rr_ready_queue_meta[cpu_id].queue_head));
        ++rr_ready_queue_meta[cpu_id].queue_len;
```
根据注释，该函数实现了一个基本的Round-robin调度算法的线程入队操作。该函数接受一个`struct thread`结构体指针作为参数，表示要将该线程加入到就绪队列中。以下是这段代码的执行过程：

首先进行一系列错误检查，如果thread为空指针、thread_ctx为空指针或者该线程的状态是TS_READY(即已经在就绪队列中)，则返回-EINVAL(参数无效)。

如果该线程的类型是TYPE_IDLE(空闲线程)，则直接返回0。

使用`smp_get_cpu_id()`函数获取该线程需要被调度的CPU ID。

如果获取到的 CPU ID 大于等于PLAT_CPU_NUM(可支持的最大CPU数量)，则返回-EINVAL。

将该线程的状态设置为TS_READY，将它的cpuid设置为获取到的CPU ID。

将该线程加入到对应CPU ID的Round-robin就绪队列中，即将它的`ready_queue_node`添加到`rr_ready_queue_meta[cpu_id].queue_head`的末尾。

增加对应CPU ID的就绪队列长度。

返回0表示线程入队成功。
## rr_sched_dequeue()
```
if (thread == NULL || thread->thread_ctx == NULL || thread->thread_ctx->state != TS_READY)
                return -EINVAL;
        list_del(&(thread->ready_queue_node));
        --rr_ready_queue_meta[thread->thread_ctx->cpuid].queue_len;
        thread->thread_ctx->state = TS_INTER;
```
根据注释，该函数实现了一个基本的Round-robin调度算法的线程出队操作。该函数接受一个`struct thread`结构体指针作为参数，表示要将该线程从就绪队列中移除。以下是这段代码的执行过程：

首先进行一系列错误检查，如果thread为空指针、thread_ctx为空指针或者该线程的状态不是TS_READY(即不在就绪队列中)，则返回-EINVAL(参数无效)。

调用`list_del()`函数将该线程从其当前所在的就绪队列中删除。

减少对应CPU ID的就绪队列长度。

将该线程的状态设置为TS_INTER(表示线程处于中间状态，不在就绪队列中)。

返回0表示线程出队成功。
## rr_sched_choose_thread()
```
u32 cpu_id = smp_get_cpu_id();
        thread = list_entry(rr_ready_queue_meta[cpu_id].queue_head.next, struct thread, ready_queue_node);
        if (rr_sched_dequeue(thread))
                return &idle_threads[cpu_id];
```
根据注释，该函数实现了一个基本的Round-robin调度算法的线程选择函数。该函数从就绪队列中选择下一个要执行的线程，并将其从队列中移除。以下是这段代码的执行过程：

首先创建一个指向`struct thread`结构体的指针 thread，初始化为NULL。

调用`smp_get_cpu_id()`函数获取当前CPU ID。

使用`list_entry`宏将`rr_ready_queue_meta[cpu_id].queue_head.next`转换为`struct thread`指针，即获取就绪队列中的第一个线程。

调用`rr_sched_dequeue()`函数将选择的线程从就绪队列中移除。如果移除失败(返回值非零)，则返回对应CPU ID的空闲线程，即`&idle_threads[cpu_id]`。

返回选择的线程。
## rr_sched()
```
struct thread *cur = current_thread;
        if (cur && cur->thread_ctx && cur->thread_ctx->type != TYPE_IDLE) {
                if (current_thread->thread_ctx->sc->budget > 0 && current_thread->thread_ctx->state != TS_WAITING 
                        && cur->thread_ctx->thread_exit_state != TE_EXITING) {
                        return 0;
                }

                if (cur->thread_ctx->thread_exit_state == TE_EXITING) {
                        cur->thread_ctx->state = TS_EXIT;
                        cur->thread_ctx->thread_exit_state = TE_EXITED;
                }
                else if (cur->thread_ctx->state != TS_WAITING) {
                        rr_sched_enqueue(cur);
                }
        }

        cur = rr_sched_choose_thread();
        rr_sched_refill_budget(cur, DEFAULT_BUDGET);
        switch_to_thread(cur);
```
