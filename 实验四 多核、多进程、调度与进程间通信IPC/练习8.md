# 答案解读：
相关函数位于oslab4\kernel\semaphore\semaphore.c中
## wait_sem()
```
if (sem->sem_count == 0) {
                if (is_block) {
                        current_thread->thread_ctx->state = TS_WAITING;
                        list_append(&(current_thread->sem_queue_node), &(sem->waiting_threads));
                        ++sem->waiting_threads_count;
                        obj_put(sem);
                        sched();
                        eret_to_thread(switch_context());
                } else ret = -EAGAIN;
        }
else --sem->sem_count;
```
根据注释，这段代码需要实现一个等待信号量的函数`wait_sem()`。代码执行过程如下：

首先判断信号量的计数值sem_count是否为0，如果是0，则表示没有可用的资源。

如果sem_count为0且is_block为真(即需要阻塞)，则将当前线程的状态设置为TS_WAITING，将当前线程添加到等待队列中，并增加等待该信号量的线程数量。然后通过`obj_put(sem)`函数释放对信号量的引用计数。调用`sched()`函数进行调度，最后通过`ret_to_thread(switch_context())`返回到新的线程上下文。这段代码实现了阻塞当前线程。

如果sem_count为0且is_block为假，则表示无需阻塞，直接将ret赋值为-EAGAIN，表示等待失败。

如果sem_count不为0，则将sem_count的值减1。
## signal_sem()
```
if(sem->waiting_threads_count > 0){
                struct thread *awake = list_entry(sem->waiting_threads.next, struct thread, sem_queue_node);
                list_del(&awake->sem_queue_node);
                --sem->waiting_threads_count;
                sched_enqueue(awake);
        }
else ++sem->sem_count;
```
根据注释，这段代码需要实现一个发送信号量的函数`signal_sem()`。代码执行过程如下：

首先判断等待该信号量的线程数量waiting_threads_count是否大于0，如果大于0，则表示有线程正在等待该信号量。

如果有等待线程，则使用list_entry宏将等待队列的第一个线程转换为struct thread结构体类型，该结构体中包含了sem_queue_node，即等待队列的节点。这样就可以得到被唤醒的线程的指针。

使用`list_del()`函数将被唤醒的线程从等待队列中删除。

将等待线程的数量减1，表示唤醒了一个线程。

调用`sched_enqueue()`函数将被唤醒的线程加入就绪队列，而不是直接切换到该线程。

如果没有等待线程，则说明没有线程在等待该信号量，直接增加信号量计数值sem_count。
