# 答案解读：
相关函数位于oslab4\kernel\sched\policy_rr.c中
## rr_sched_refill_budget()
```
target->thread_ctx->sc->budget = budget;
```
根据ppt这里需要给当前线程重新填满默认的预算DEFAULT_BUDGET。同时该函数接受两个参数：target表示要修改预算的线程指针，budget表示新的预算值。所以只需将budget赋值给target线程的预算值。

## rr_sched()
```
struct thread *cur = current_thread;
        if (cur && cur->thread_ctx && cur->thread_ctx->type != TYPE_IDLE) {
                if (current_thread->thread_ctx->sc->budget > 0 && current_thread->thread_ctx->state != TS_WAITING 
                        && cur->thread_ctx->thread_exit_state != TE_EXITING) {
                        return 0;
                }

                if (cur->thread_ctx->thread_exit_state == TE_EXITING) {
                        cur->thread_ctx->state = TS_EXIT;
                        cur->thread_ctx->thread_exit_state = TE_EXITED;
                }
                else if (cur->thread_ctx->state != TS_WAITING) {
                        rr_sched_enqueue(cur);
                }
        }

        cur = rr_sched_choose_thread();
        rr_sched_refill_budget(cur, DEFAULT_BUDGET);
        switch_to_thread(cur);
```
由于看不到`rr_sched()`的初始实现，这里也先留着。

`rr_sched_refill_budget()`函数上方的注释中提到`rr_sched()`中需要调用`rr_sched_refill_budget()`。

相关函数位于oslab4\kernel\sched\sched.c中
## sched_handle_timer_irq()
```
if (current_thread && current_thread->thread_ctx && current_thread->thread_ctx->sc && current_thread->thread_ctx->sc->budget && current_thread->thread_ctx->sc->budget > 0)
{
        --current_thread->thread_ctx->sc->budget;
}
```
根据注释，该函数需要检查当前线程及其上下文是否存在，同时还要判断当前线程的预算是否大于0。如果以上条件都满足，则将当前线程的预算值减1，表示当前线程消耗了一个时间片。
